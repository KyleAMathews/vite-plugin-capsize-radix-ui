import { Plugin } from "vite"
import fs from "fs"
import {
  createStyleObject,
  createStyleString,
  createFontStack,
  FontMetrics,
} from "@capsizecss/core"
import Mustache from "mustache"
import path from "path"

// Type for createFontStack return value
interface FontStackResult {
  fontFamily: string
  fontFaces: string
}

// Metrics for system fonts
import segoeUI from "@capsizecss/metrics/segoeUI"
import appleSystem from "@capsizecss/metrics/appleSystem"
import roboto from "@capsizecss/metrics/roboto"
import ubuntu from "@capsizecss/metrics/ubuntu"
import notoSans from "@capsizecss/metrics/notoSans"

// Text elements that should receive capsize trimming
// Note: createStyleString prepends a "." so we use a placeholder and replace it
const TEXT_ELEMENTS = `.rt-Text, .rt-Heading, .rt-Em, .rt-Quote, .rt-Link`
const TEXT_SELECTOR_PLACEHOLDER = `__CAPSIZE_TEXT__`
const TEXT_SELECTOR_REPLACEMENT = `:where(${TEXT_ELEMENTS})`

const template = `/* Auto-generated by vite-plugin-capsize-radix */

/* Fallback font-face rules for metric-adjusted fallbacks */
{{{defaultFontFamily.fontFaces}}}
{{{headingFontFamily.fontFaces}}}
{{{codingFontFamily.fontFaces}}}

/* Override Radix variables */
.radix-themes {
  --default-font-family: {{{defaultFontFamily.fontFamily}}};
  --em-font-family: {{{defaultFontFamily.fontFamily}}};
  --quote-font-family: {{{defaultFontFamily.fontFamily}}};
  --heading-font-family: {{{headingFontFamily.fontFamily}}};
  --code-font-family: {{{codingFontFamily.fontFamily}}};

  /* Mobile */
{{#mobileFontData}}
  --font-size-{{{i}}}: {{{fontSize}}};
  --line-height-{{{i}}}: {{{lineHeight}}};
  --heading-line-height-{{{i}}}: {{{lineHeight}}};
{{/mobileFontData}}

  /* Larger devices */
  @media (min-width: 768px) {
  {{#fontData}}
    --font-size-{{{i}}}: {{{fontSize}}};
    --line-height-{{{i}}}: {{{lineHeight}}};
    --heading-line-height-{{{i}}}: {{{lineHeight}}};
  {{/fontData}}
  }
}

/* Otherwise links don't flow inline */
.rt-Link {
  display: inline-block;
}

/* Default text styles */
{{{mobileTextStyles}}}
@media (min-width: 768px) {
  {{{textStyles}}}
}

/* Em text styles */
{{{mobileEmStyles}}}
@media (min-width: 768px) {
  {{{emStyles}}}
}

/* Quote text styles */
{{{mobileQuoteStyles}}}
@media (min-width: 768px) {
  {{{quoteStyles}}}
}

/* Code text styles */
{{{mobileCodeStyles}}}
@media (min-width: 768px) {
  {{{codeStyles}}}
}

/* Code size variants */
{{#mobileCodeFontData}}
{{{style}}}
{{/mobileCodeFontData}}
@media (min-width: 768px) {
  {{#codeFontData}}
  {{{style}}}
  {{/codeFontData}}
}

.rt-Em, .rt-Quote, .rt-Code {
  display: inline-block;
}

/* Size variants for text elements only */
{{#mobileFontData}}
{{{style}}}
{{/mobileFontData}}
@media (min-width: 768px) {
  {{#fontData}}
  {{{style}}}
  {{/fontData}}
}

/* Utility class to preserve descenders (opt-in) */
.preserve-descenders::after {
  display: none !important;
}
`

function validateOptions(options: OptionsWithDefaults): void {
  if (!options.outputPath) {
    throw new Error(`[capsize-radix] outputPath is required`)
  }

  if (options.textStyles.length < 3) {
    throw new Error(
      `[capsize-radix] textStyles must have at least 3 entries (found ${options.textStyles.length})`
    )
  }

  for (let i = 0; i < options.textStyles.length; i++) {
    const style = options.textStyles[i]
    if (typeof style.fontSize !== `number` || style.fontSize <= 0) {
      throw new Error(
        `[capsize-radix] textStyles[${i}].fontSize must be a positive number`
      )
    }
    if (typeof style.lineHeight !== `number` || style.lineHeight <= 0) {
      throw new Error(
        `[capsize-radix] textStyles[${i}].lineHeight must be a positive number`
      )
    }
  }

  // Validate output directory exists
  const outputDir = path.dirname(options.outputPath)
  if (!fs.existsSync(outputDir)) {
    throw new Error(
      `[capsize-radix] Output directory does not exist: ${outputDir}`
    )
  }
}

function generate(options: OptionsWithDefaults) {
  validateOptions(options)

  let defaultFontFamily: FontStackResult
  let headingFontFamily: FontStackResult
  let codingFontFamily: FontStackResult

  if (!options.defaultFontStack) {
    options.defaultFontStack = [
      appleSystem,
      segoeUI,
      roboto,
      ubuntu,
      notoSans,
    ] as unknown as FontMetrics[]
    defaultFontFamily = createFontStack(options.defaultFontStack)

    // We prefer to deterministically pick the font w/ the stack above so then the font trimmings work
    // but we if we can't, we'll fall back to these.
    defaultFontFamily.fontFamily += `, ui-sans-serif, system-ui, sans-serif`
  } else {
    defaultFontFamily = createFontStack(options.defaultFontStack)
  }

  if (options.headingFontStack) {
    headingFontFamily = createFontStack(options.headingFontStack)
  } else {
    headingFontFamily = defaultFontFamily
  }

  if (options.codingFontStack) {
    codingFontFamily = createFontStack(options.codingFontStack)
  } else {
    options.codingFontStack = [appleSystem] as unknown as FontMetrics[]
    codingFontFamily = createFontStack(options.codingFontStack)

    // We prefer to deterministically pick the font w/ the stack above so then the font trimmings work
    // but we if we can't, we'll fall back to these.
    codingFontFamily.fontFamily += `, ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace`
  }

  const mobileFontData = [
    options.textStyles[0],
    ...options.textStyles.slice(1),
  ].map(({ fontSize, lineHeight }, i) => {
    const lineGap = lineHeight - fontSize
    const style = createStyleString(
      `${TEXT_SELECTOR_PLACEHOLDER}.rt-r-size-${i + 1}`,
      {
        capHeight: fontSize,
        lineGap,
        fontMetrics: options.defaultFontStack![0],
      }
    )
    return {
      style,
      ...createStyleObject({
        capHeight: fontSize,
        lineGap,
        fontMetrics: options.defaultFontStack![0],
      }),
      i: i + 1,
    }
  })

  // Generate code-specific styles for each size variant
  const mobileCodeFontData = [
    options.textStyles[0],
    ...options.textStyles.slice(1),
  ].map(({ fontSize, lineHeight }, i) => {
    const lineGap = lineHeight - fontSize
    const style = createStyleString(`rt-Code.rt-r-size-${i + 1}`, {
      capHeight: fontSize * 0.95,
      lineGap,
      fontMetrics: options.codingFontStack![0],
    })
    return {
      style,
      ...createStyleObject({
        capHeight: fontSize * 0.95,
        lineGap,
        fontMetrics: options.codingFontStack![0],
      }),
      i: i + 1,
    }
  })

  const fontData = options.textStyles.map(({ fontSize, lineHeight }, i) => {
    const lineGap = lineHeight - fontSize
    const style = createStyleString(
      `${TEXT_SELECTOR_PLACEHOLDER}.rt-r-size-${i + 1}`,
      {
        capHeight: fontSize,
        lineGap,
        fontMetrics: options.defaultFontStack![0],
      }
    )
    return {
      style,
      ...createStyleObject({
        capHeight: fontSize,
        lineGap,
        fontMetrics: options.defaultFontStack![0],
      }),
      i: i + 1,
    }
  })

  // Generate code-specific styles for each size variant for larger screens
  const codeFontData = options.textStyles.map(({ fontSize, lineHeight }, i) => {
    const lineGap = lineHeight - fontSize
    const style = createStyleString(`rt-Code.rt-r-size-${i + 1}`, {
      capHeight: fontSize,
      lineGap,
      fontMetrics: options.codingFontStack![0],
    })
    return {
      style,
      ...createStyleObject({
        capHeight: fontSize,
        lineGap,
        fontMetrics: options.codingFontStack![0],
      }),
      i: i + 1,
    }
  })

  const mobileTextStyles = createStyleString(`rt-Text`, {
    capHeight: options.textStyles[1].fontSize,
    lineGap: options.textStyles[1].lineHeight - options.textStyles[1].fontSize,
    fontMetrics: options.defaultFontStack![0],
  })
  const mobileEmStyles = createStyleString(`rt-Em`, {
    capHeight: options.textStyles[1].fontSize,
    lineGap: options.textStyles[1].lineHeight - options.textStyles[1].fontSize,
    fontMetrics: options.defaultFontStack![0],
  })
  const mobileQuoteStyles = createStyleString(`rt-Quote`, {
    capHeight: options.textStyles[1].fontSize,
    lineGap: options.textStyles[1].lineHeight - options.textStyles[1].fontSize,
    fontMetrics: options.defaultFontStack![0],
  })
  const mobileCodeStyles = createStyleString(`rt-Code`, {
    capHeight: options.textStyles[1].fontSize * 0.95,
    lineGap: options.textStyles[1].lineHeight - options.textStyles[1].fontSize,
    fontMetrics: options.codingFontStack[0],
  })

  const textStyles = createStyleString(`rt-Text`, {
    capHeight: options.textStyles[2].fontSize,
    lineGap: options.textStyles[2].lineHeight - options.textStyles[2].fontSize,
    fontMetrics: options.defaultFontStack![0],
  })
  const emStyles = createStyleString(`rt-Em`, {
    capHeight: options.textStyles[2].fontSize,
    lineGap: options.textStyles[2].lineHeight - options.textStyles[2].fontSize,
    fontMetrics: options.defaultFontStack![0],
  })
  const quoteStyles = createStyleString(`rt-Quote`, {
    capHeight: options.textStyles[2].fontSize,
    lineGap: options.textStyles[2].lineHeight - options.textStyles[2].fontSize,
    fontMetrics: options.defaultFontStack![0],
  })

  const codeStyles = createStyleString(`rt-Code`, {
    capHeight: options.textStyles[2].fontSize * 0.95,
    lineGap: options.textStyles[2].lineHeight - options.textStyles[2].fontSize,
    fontMetrics: options.codingFontStack[0],
  })

  const output = Mustache.render(template, {
    headingFontFamily,
    defaultFontFamily,
    codingFontFamily,
    mobileFontData,
    fontData,
    mobileCodeFontData,
    codeFontData,
    mobileTextStyles,
    textStyles,
    mobileEmStyles,
    emStyles,
    mobileQuoteStyles,
    quoteStyles,
    mobileCodeStyles,
    codeStyles,
  })

  // Replace placeholder with actual :where() selector
  // createStyleString prepends "." so we replace ".__CAPSIZE_TEXT__" with ":where(...)"
  const placeholderRegex = new RegExp(`\\.${TEXT_SELECTOR_PLACEHOLDER}`, `g`)
  const finalOutput = output.replace(
    placeholderRegex,
    TEXT_SELECTOR_REPLACEMENT
  )

  try {
    fs.writeFileSync(options.outputPath, finalOutput)
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error)
    throw new Error(
      `[capsize-radix] Failed to write CSS to ${options.outputPath}: ${message}`
    )
  }
}

interface TextStyle {
  fontSize: number
  lineHeight: number
}

interface Options {
  outputPath: string
  textStyles?: TextStyle[]
  defaultFontStack?: FontMetrics[]
  headingFontStack?: FontMetrics[]
  codingFontStack?: FontMetrics[]
}
interface OptionsWithDefaults {
  outputPath: string
  textStyles: TextStyle[]
  defaultFontStack?: FontMetrics[]
  headingFontStack?: FontMetrics[]
  codingFontStack?: FontMetrics[]
}
export function capsizeRadixPlugin({
  outputPath,
  textStyles = [
    { fontSize: 9, lineHeight: 19 },
    { fontSize: 11, lineHeight: 23 },
    { fontSize: 12, lineHeight: 25 },
    { fontSize: 14, lineHeight: 28 },
    { fontSize: 18, lineHeight: 30 },
    { fontSize: 24, lineHeight: 36 },
    { fontSize: 36, lineHeight: 48 },
    { fontSize: 48, lineHeight: 60 },
    { fontSize: 64, lineHeight: 80 },
  ],
  defaultFontStack,
  headingFontStack,
  codingFontStack,
}: Options): Plugin {
  return {
    name: `radix-capsize-plugin`,
    buildStart() {
      generate({
        outputPath,
        textStyles,
        defaultFontStack,
        headingFontStack,
        codingFontStack,
      })
    },
  }
}
